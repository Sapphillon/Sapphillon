# 内部プラグインビルドシステム自動化機能

## 概要

Sapphillonのビルドシステムは、`js_plugins`ディレクトリ内の内部プラグインを自動的に発見し、登録する機能を提供します。この機能により、開発者は手動でプラグイン情報を管理する必要がなくなり、新しい内部プラグインを追加する際の作業が大幅に簡素化されます。

### 主な特徴

- **自動発見**: `js_plugins`ディレクトリを再帰的にスキャンして、`package.js`ファイルを含むプラグインを自動的に検出
- **コード生成**: 発見されたプラグインの情報から`src/internal_plugins.rs`ファイルを自動生成
- **安定した順序**: プラグインはアルファベット順でソートされ、常に同じ順序で返される
- **ビルド時の再生成**: `js_plugins`ディレクトリに変更があると、ビルドスクリプトが再実行され、コードが再生成される

## ディレクトリ構成

内部プラグインのディレクトリ構成は以下のようになっています：

```
js_plugins/
├── {author_id}/
│   ├── {package_id}/
│   │   └── {version}/
│   │       ├── package.js      # プラグイン情報ファイル
│   │       └── ...             # その他のプラグインファイル
│   └── ...
└── ...
```

### ディレクトリ構成の例

```
js_plugins/
└── test/
    ├── example/
    │   └── 1.0.0/
    │       └── package.js
    ├── plugin-a/
    │   └── 1.0.0/
    │       └── package.js
    ├── plugin-b/
    │   └── 1.0.0/
    │       └── package.js
    └── plugin-c/
        └── 1.0.0/
            └── package.js
```

### パスパターン

- **必須パターン**: `js_plugins/{author_id}/{package_id}/{version}/package.js`
- **author_id**: プラグイン作者の識別子（例: `app.sapphillon`）
- **package_id**: プラグインの識別子（例: `example`）
- **version**: セマンティックバージョニング（例: `1.0.0`）

## ビルドプロセスの仕組み

### ビルドスクリプトのフロー

```
┌─────────────────────────────────────────────────────────────┐
│                    cargo build 実行                           │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│              build.rs の main() 関数実行                      │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│         discover_internal_plugins() を呼び出し                │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│    js_plugins ディレクトリの存在チェック                        │
│    (存在しない場合は警告を出力して終了)                        │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│    find_package_files() で package.js を再帰検索               │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│    extract_plugin_info() で各プラグインの情報を抽出            │
│    - パス構造の検証                                           │
│    - バージョン形式の検証                                      │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│    generate_internal_plugins_file() でコード生成              │
│    - src/internal_plugins.rs を作成                           │
│    - プラグイン情報をアルファベット順で出力                     │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│    cargo:rerun-if-changed=js_plugins を出力                   │
│    (js_plugins ディレクトリの変更を監視)                       │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│              ビルドの継続（Rust コンパイル）                    │
└─────────────────────────────────────────────────────────────┘
```

### 自動生成されるコード

ビルドスクリプトは`src/internal_plugins.rs`ファイルを自動生成します。このファイルには以下の内容が含まれます：

```rust
// Sapphillon
// SPDX-FileCopyrightText: 2025 Yuta Takahashi
// SPDX-License-Identifier: MPL-2.0 OR GPL-3.0-or-later
//
// This file is automatically generated by build.rs
// DO NOT EDIT THIS FILE MANUALLY
//
// This file contains information about internal plugins discovered
// from the js_plugins directory during build time.

use entity::entity::plugin_package::Model as PluginPackage;

/// Returns a list of internal plugins discovered at build time.
///
/// This function returns plugin information for all internal plugins
/// found in the js_plugins directory. The plugins are returned in
/// alphabetical order by package_id for stable ordering.
pub fn internal_plugins() -> Vec<PluginPackage> {
    let mut plugins = Vec::new();

    plugins.push(PluginPackage {
        package_id: "app.sapphillon/example/1.0.0".to_string(),
        package_name: "example".to_string(),
        package_version: "1.0.0".to_string(),
        description: None,
        plugin_store_url: None,
        internal_plugin: true,
        verified: true,
        deprecated: false,
        installed_at: None,
        updated_at: None,
    });

    // ... 他のプラグイン

    plugins
}
```

### プラグイン情報の構造

自動生成される各プラグインの情報は以下の構造を持ちます：

| フィールド | 値 | 説明 |
|-----------|-----|------|
| `package_id` | `{author_id}/{package_id}/{version}` | プラグインの一意識別子 |
| `package_name` | `{package_id}` | プラグイン名 |
| `package_version` | `{version}` | バージョン |
| `description` | `None` | 説明（現在は未使用） |
| `plugin_store_url` | `None` | プラグインストアURL（内部プラグインはなし） |
| `internal_plugin` | `true` | 内部プラグインフラグ |
| `verified` | `true` | 検証済みフラグ |
| `deprecated` | `false` | 非推奨フラグ |
| `installed_at` | `None` | インストール日時（内部プラグインはなし） |
| `updated_at` | `None` | 更新日時（内部プラグインはなし） |

## 利用方法

### 内部プラグインの取得

アプリケーションコードから内部プラグインの情報を取得するには、`internal_plugins()`関数を使用します：

```rust
use Sapphillon_Controller::internal_plugins;

fn main() {
    let plugins = internal_plugins();
    
    for plugin in plugins {
        println!("Plugin: {}", plugin.package_id);
        println!("  Name: {}", plugin.package_name);
        println!("  Version: {}", plugin.package_version);
        println!("  Internal: {}", plugin.internal_plugin);
    }
}
```

### ビルド時の自動実行

ビルドシステムは`cargo build`または`cargo test`コマンドを実行する際に自動的に動作します。特別な設定や手動実行は必要ありません。

```bash
# 通常のビルドで自動的に内部プラグインが発見・登録されます
cargo build

# テスト実行時にも自動的に行われます
cargo test
```

### ビルド出力の確認

ビルド時に発見されたプラグインは警告メッセージとして出力されます：

```bash
$ cargo build
   Compiling Sapphillon_Controller v0.1.0
warning: Discovered 4 internal plugin(s):
warning:   - test/example/1.0.0 (name: example, version: 1.0.0)
warning:   - test/plugin-a/1.0.0 (name: plugin-a, version: 1.0.0)
warning:   - test/plugin-b/1.0.0 (name: plugin-b, version: 1.0.0)
warning:   - test/plugin-c/1.0.0 (name: plugin-c, version: 1.0.0)
    Finished dev [unoptimized + debuginfo] target(s) in 2.45s
```

## 新規プラグインの追加手順

### ステップ1: ディレクトリ構造の作成

新しい内部プラグインを追加するには、`js_plugins`ディレクトリ内に適切なディレクトリ構造を作成します：

```bash
# ディレクトリ構造の作成
mkdir -p js_plugins/test/my-plugin/1.0.0
```

### ステップ2: package.jsファイルの作成

`package.js`ファイルを作成し、プラグイン情報を定義します：

```javascript
// Sapphillon
// SPDX-FileCopyrightText: 2025 Yuta Takahashi
// SPDX-License-Identifier: MPL-2.0 OR GPL-3.0-or-later

export default {
    name: "my-plugin",
    version: "1.0.0",
    description: "My custom internal plugin",
    functions: [
        {
            name: "myFunction",
            description: "A sample function",
            parameters: {
                type: "object",
                properties: {
                    input: {
                        type: "string",
                        description: "Input parameter"
                    }
                },
                required: ["input"]
            }
        }
    ]
};
```

### ステップ3: プラグインの実装

必要に応じて、プラグインの実装ファイルを追加します：

```bash
# 例: index.jsファイルの作成
touch js_plugins/test/my-plugin/1.0.0/index.js
```

### ステップ4: ビルドの実行

通常通りビルドを実行すると、新しいプラグインが自動的に発見・登録されます：

```bash
cargo build
```

### 完全な追加例

以下は、新しいプラグイン「hello-world」を追加する完全な例です：

```bash
# 1. ディレクトリ作成
mkdir -p js_plugins/test/hello-world/1.0.0

# 2. package.js作成
cat > js_plugins/test/hello-world/1.0.0/package.js << 'EOF'
// Sapphillon
// SPDX-FileCopyrightText: 2025 Yuta Takahashi
// SPDX-License-Identifier: MPL-2.0 OR GPL-3.0-or-later

export default {
    name: "hello-world",
    version: "1.0.0",
    description: "A simple hello world plugin",
    functions: [
        {
            name: "sayHello",
            description: "Returns a greeting message",
            parameters: {
                type: "object",
                properties: {
                    name: {
                        type: "string",
                        description: "Name to greet"
                    }
                },
                required: ["name"]
            }
        }
    ]
};
EOF

# 3. ビルド実行
cargo build
```

## 注意点

### 重要な注意事項

1. **自動生成ファイルの編集禁止**
   - `src/internal_plugins.rs`はビルドスクリプトによって自動生成されます
   - 手動で編集しても、次回のビルドで上書きされます
   - ファイルの先頭には`// DO NOT EDIT THIS FILE MANUALLY`という警告が含まれています

2. **ディレクトリ構造の厳守**
   - `js_plugins/{author_id}/{package_id}/{version}/package.js`のパターンを厳守する必要があります
   - パターンに合致しないファイルは警告を出力してスキップされます

3. **バージョン形式の検証**
   - バージョンは数字で始まる必要があります（基本的なセマンティックバージョニングチェック）
   - 不正なバージョン形式の場合、警告が出力され、そのプラグインはスキップされます

4. **Windowsサポートの制限**
   - 現在、Windowsサポートは一時停止されています
   - `build.rs`には`#[cfg(target_os = "windows")]`でコンパイルエラーが設定されています

5. **アルファベット順のソート**
   - プラグインは`package_id`のアルファベット順でソートされます
   - これは`BTreeMap`を使用して実現されており、常に安定した順序を保証します

6. **ビルド時の再生成**
   - `js_plugins`ディレクトリに変更があると、ビルドスクリプトが再実行されます
   - これは`cargo:rerun-if-changed=js_plugins`ディレクティブによって制御されています

### エラーハンドリング

ビルドシステムは以下のエラー状況に対処します：

| エラー状況 | 対処方法 |
|-----------|---------|
| `js_plugins`ディレクトリが存在しない | 警告を出力して正常終了 |
| `package.js`ファイルが見つからない | 警告を出力して正常終了 |
| パス構造が不正 | 警告を出力してそのファイルをスキップ |
| バージョン形式が不正 | 警告を出力してそのプラグインをスキップ |
| ディレクトリ読み取りエラー | 警告を出力して正常終了 |

### テスト

ビルドシステムの機能は`tests/build_system.rs`で包括的にテストされています：

```bash
# ビルドシステムのテストを実行
cargo test --test build_system
```

テストは以下の項目を検証します：

- プラグインの数が正しいこと
- 各プラグインの情報が正しいこと
- `internal_plugin`フラグが`true`であること
- `plugin_store_url`が`None`であること
- プラグインがアルファベット順でソートされていること
- `verified`フラグが`true`であること
- `deprecated`フラグが`false`であること
- `description`が`None`であること
- `installed_at`と`updated_at`が`None`であること
- `package_id`の形式が正しいこと
- 複数回の呼び出しで結果が一貫していること

### パフォーマンスに関する考慮事項

- ビルドスクリプトはビルド時にのみ実行されるため、実行時のパフォーマンスには影響しません
- `BTreeMap`を使用することで、プラグインのソートが効率的に行われます
- 再帰的なディレクトリ探索は`js_plugins`ディレクトリ内でのみ行われます

### 将来の拡張性

現在の実装は以下の拡張に対応可能です：

- プラグインのメタデータ（説明、作者、ライセンスなど）の追加
- バージョン形式のより厳密な検証
- 依存関係の管理
- プラグインの有効化/無効化機能
- プラグインのカテゴリ分類

## 関連ファイル

| ファイル | 説明 |
|---------|------|
| `build.rs` | ビルドスクリプト（プラグインの発見とコード生成） |
| `src/internal_plugins.rs` | 自動生成されるプラグイン情報ファイル |
| `tests/build_system.rs` | ビルドシステムの統合テスト |
| `js_plugins/` | 内部プラグインのディレクトリ |

## トラブルシューティング

### 問題: 新しいプラグインが認識されない

**解決策:**
1. ディレクトリ構造が正しいか確認してください
2. `package.js`ファイルが正しい場所に存在するか確認してください
3. バージョンが数字で始まっているか確認してください
4. `cargo clean && cargo build`を実行してクリーンビルドを試してください

### 問題: ビルド時に警告が表示される

**解決策:**
1. 警告メッセージを確認して、どのファイルで問題が発生しているか特定してください
2. パス構造やバージョン形式が正しいか確認してください
3. 不正なファイルを修正または削除してください

### 問題: テストが失敗する

**解決策:**
1. `src/internal_plugins.rs`が手動で編集されていないか確認してください
2. `js_plugins`ディレクトリの内容が正しいか確認してください
3. `cargo clean && cargo test --test build_system`を実行してクリーンビルドを試してください
