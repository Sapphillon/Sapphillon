// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Permission {
    #[prost(string, tag="1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration="PermissionType", tag="3")]
    pub permission_type: i32,
    /// The resource this permission applies to, e.g., "file.txt"
    #[prost(string, repeated, tag="4")]
    pub resource: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration="PermissionLevel", tag="5")]
    pub permission_level: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PermissionType {
    Unspecified = 0,
    Read = 1,
    Write = 2,
    Execute = 3,
}
impl PermissionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PermissionType::Unspecified => "PERMISSION_TYPE_UNSPECIFIED",
            PermissionType::Read => "PERMISSION_TYPE_READ",
            PermissionType::Write => "PERMISSION_TYPE_WRITE",
            PermissionType::Execute => "PERMISSION_TYPE_EXECUTE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PERMISSION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PERMISSION_TYPE_READ" => Some(Self::Read),
            "PERMISSION_TYPE_WRITE" => Some(Self::Write),
            "PERMISSION_TYPE_EXECUTE" => Some(Self::Execute),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PermissionLevel {
    Unspecified = 0,
    Medium = 1,
    High = 2,
    Critical = 3,
}
impl PermissionLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PermissionLevel::Unspecified => "PERMISSION_LEVEL_UNSPECIFIED",
            PermissionLevel::Medium => "PERMISSION_LEVEL_MEDIUM",
            PermissionLevel::High => "PERMISSION_LEVEL_HIGH",
            PermissionLevel::Critical => "PERMISSION_LEVEL_CRITICAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PERMISSION_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "PERMISSION_LEVEL_MEDIUM" => Some(Self::Medium),
            "PERMISSION_LEVEL_HIGH" => Some(Self::High),
            "PERMISSION_LEVEL_CRITICAL" => Some(Self::Critical),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PluginFunction {
    /// Unique identifier for the function
    #[prost(string, tag="1")]
    pub function_id: ::prost::alloc::string::String,
    /// Name of the function
    #[prost(string, tag="2")]
    pub function_name: ::prost::alloc::string::String,
    /// Description of what the function does
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    /// Permissions required to execute this function
    #[prost(message, repeated, tag="4")]
    pub permissions: ::prost::alloc::vec::Vec<Permission>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PluginPackage {
    #[prost(string, tag="1")]
    pub package_id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub package_name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub package_version: ::prost::alloc::string::String,
    #[prost(string, tag="4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="5")]
    pub functions: ::prost::alloc::vec::Vec<PluginFunction>,
    #[prost(string, tag="6")]
    pub plugin_store_url: ::prost::alloc::string::String,
    #[prost(bool, optional, tag="7")]
    pub internal_plugin: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="8")]
    pub verified: ::core::option::Option<bool>,
    #[prost(bool, optional, tag="9")]
    pub deprecated: ::core::option::Option<bool>,
    #[prost(message, optional, tag="10")]
    pub installed_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="11")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Version {
    /// The version of the application
    #[prost(string, tag="1")]
    pub version: ::prost::alloc::string::String,
}
/// This message can be extended in the future if needed.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetVersionRequest {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVersionResponse {
    /// The current version of the application
    #[prost(message, optional, tag="1")]
    pub version: ::core::option::Option<Version>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowCode {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int32, tag="2")]
    pub code_revision: i32,
    #[prost(string, tag="3")]
    pub code: ::prost::alloc::string::String,
    #[prost(enumeration="WorkflowLanguage", tag="4")]
    pub language: i32,
    #[prost(message, optional, tag="5")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, optional, tag="6")]
    pub result: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag="7")]
    pub required_permissions: ::prost::alloc::vec::Vec<Permission>,
}
/// TODO Add data types to properly represent the results
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowResult {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    /// The result of the workflow execution
    #[prost(string, tag="4")]
    pub result: ::prost::alloc::string::String,
    #[prost(message, optional, tag="5")]
    pub ran_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration="WorkflowResultType", tag="6")]
    pub result_type: i32,
    /// Exit code of the workflow execution
    #[prost(int32, tag="7")]
    pub exit_code: i32,
    /// Revision of the workflow code that produced this result
    #[prost(int32, tag="8")]
    pub workflow_code_revision: i32,
    /// Revision of the workflow result
    #[prost(int32, tag="9")]
    pub workflow_result_revision: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Workflow {
    #[prost(string, tag="1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration="WorkflowLanguage", tag="4")]
    pub workflow_language: i32,
    #[prost(message, repeated, tag="5")]
    pub workflow_code: ::prost::alloc::vec::Vec<WorkflowCode>,
    #[prost(message, optional, tag="6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag="7")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, repeated, tag="8")]
    pub workflow_results: ::prost::alloc::vec::Vec<WorkflowResult>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkflowLanguage {
    Unspecified = 0,
    Typescript = 1,
    Javascript = 2,
}
impl WorkflowLanguage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WorkflowLanguage::Unspecified => "WORKFLOW_LANGUAGE_UNSPECIFIED",
            WorkflowLanguage::Typescript => "WORKFLOW_LANGUAGE_TYPESCRIPT",
            WorkflowLanguage::Javascript => "WORKFLOW_LANGUAGE_JAVASCRIPT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKFLOW_LANGUAGE_UNSPECIFIED" => Some(Self::Unspecified),
            "WORKFLOW_LANGUAGE_TYPESCRIPT" => Some(Self::Typescript),
            "WORKFLOW_LANGUAGE_JAVASCRIPT" => Some(Self::Javascript),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkflowResultType {
    SuccessUnspecified = 0,
    Failure = 1,
}
impl WorkflowResultType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WorkflowResultType::SuccessUnspecified => "WORKFLOW_RESULT_TYPE_SUCCESS_UNSPECIFIED",
            WorkflowResultType::Failure => "WORKFLOW_RESULT_TYPE_FAILURE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKFLOW_RESULT_TYPE_SUCCESS_UNSPECIFIED" => Some(Self::SuccessUnspecified),
            "WORKFLOW_RESULT_TYPE_FAILURE" => Some(Self::Failure),
            _ => None,
        }
    }
}
/// Request message for generating a workflow.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateWorkflowRequest {
    /// The natural language prompt describing the desired workflow.
    /// e.g., "Check the weather, and if it's raining, send me a notification."
    #[prost(string, tag="1")]
    pub prompt: ::prost::alloc::string::String,
}
/// Response message containing the generated workflow.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateWorkflowResponse {
    /// The structured workflow definition.
    /// The format of this definition can be JSON, YAML, or another
    /// structured format, represented as a string.
    #[prost(string, tag="1")]
    pub workflow_definition: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FixWorkflowRequest {
    /// The workflow definition to be fixed.
    /// This should be a structured format like JSON or YAML.
    #[prost(string, tag="1")]
    pub workflow_definition: ::prost::alloc::string::String,
    /// A description of the issues to fix.
    /// This can help guide the fixing process.
    #[prost(string, tag="2")]
    pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FixWorkflowResponse {
    /// The fixed workflow definition.
    /// This should be a structured format like JSON or YAML.
    #[prost(string, tag="1")]
    pub fixed_workflow_definition: ::prost::alloc::string::String,
    /// A summary of the changes made to fix the workflow.
    /// This can help users understand what was changed.
    #[prost(string, tag="2")]
    pub change_summary: ::prost::alloc::string::String,
}
include!("sapphillon.v1.tonic.rs");
// @@protoc_insertion_point(module)